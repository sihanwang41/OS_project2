Shanlongchaun Gu (sg3208)
Andrew Kallem (ajk2214)
Sihan Wang (sw2921)
CS 4118 - Operating Systems
Homework 2, Programming Problems


General Notes:
The main implementation of our system call can be found in kernel/ptree.c.  The header file for the prinfo structure is in include/linux/prinfo.h.

Our test program is located in the root directory of the repository and is named ptree.c.  Running 'make' in that directory will make the test program, which can then be pushed to an emulator using adb push and run using adb shell.

The results directory includes the output of our test program at various times during our interaction with the emulator (discussed in more detail below).

The test program is currently hardcoded to set nr at 500, which is far more than then number of available processes, making it easier for us to do the investigation in Question 4.  Of course, it is a simple edit to test the program with other values of nr (including invalid parameters for both nr and buf), and we performed such tests to ensure our system call was robust to attack.


Question 4:
To help answer these questions, we ran our ptree test script multiple times at several steps during our interaction with the emulator, redirecting the output to files so that we could more easily compare them using the diff command.  We found it important to do this in order to be sure that our interaction with the emulator is what caused the change in the process tree, rather than some previous interaction that was slow to process.

The output of each run can be found in the results directory.  The files we generated by running ptree in the following order:
- loading1.txt to loading5.txt - Run every few seconds as the emulator was booting up
- lock1.txt to lock6.txt - Run every few seconds on the Android lock screen until the process tree was stable
- unlock1.txt to unlock3.txt - Run every few seconds on the Android home screen (after unlocking) until the process tree was stable
- browser1.txt to browser3.txt - Run every few seconds after opening the browser until the process tree was stable
- home1.txt to home2.txt - Run every few seconds after closing the browser and returning to the home screen
- calculator1.txt - Run after opening the calculator app
- calculatorKill.txt - Run after exiting the calculation app and force quitting it

(a)
As the Android OS boots (loading1.txt to loading6.txt), the fields we observed to change most commonly are the state fields.  For example, comparing loading1.txt to loading2.txt, the state of zygote changed from 130 to 0, and the state of mtdblock0 changed from 1 to 0.  The states for both of these processes changed back comparing loading2.txt with loading3.txt.

In addition, of course, each time we ran our ptree test script, a process was created parented by the adbd process to represent the program in execution.  As a result, each time we ran it, we see a new pid for ptree and a new youngest child field for adbd, its parent.

Since the state field represents whether the task is running, interruptible, uninterruptible, a zombie, killed, etc., it makes sense that we should see changes over time, particularly as the scheduler switches between processes.  We would expect these to change from time to time even if no new processes are being created or destroyed, merely due to scheduler activity.

The youngest child field also changes for the parent any time it forks a new child.  The frequency simply depends on how often new processes are created, which from our observation occurs interrmittently during the loading process and infrequently thereafter (except as we discuss below).
 
We did not observe any cases where the process uid changed, which makes sense since it is the user id of the process owner and should not change over the process's lifetime.

(b)
Comparing unlock3.txt (run just before launching the browser) with browser1.txt (run several after the browser loaded), we see two processes were created: android.browser and kworker/0:0.  android.browser's parent process is zygote and kworker/0:0 's parent is kthreadd.  There were no other changes from the time we ran browser1.txt to the time we ran browser3.txt several seconds later.

Comparing browser3.txt (run just before closing the browser) with home1.txt (run just after closing the browser) or home2.txt (run several seconds later), we see that no processes were destroyed after closing the browser.

Our explanation is that, when an application such as the browser is run, it (obviously) causes a process to be created to represent that program during execution.  However, when we close the browser, the process is not actually terminated immediately.  It is more like minimizing a window in Windows; the program is still running in the background.  This way, a user can reopen the browser and pick up right where they left off without any delay.

(c)
i.
We noted that essentially all of the children of zygote are "apps" (in the sense of Android or iOS apps), such as the phone, calendar, email, and browser apps.  To validate this, we opened the calculator app and, not surprisingly, found that android.calculator2 became a child of zygote (see calculator1.txt).

Therefore, we believe the purpose of zygote is to run in the background and fork/exec when necessary to launch an app (such as when the user taps on an app icon).  We also believe it has certain decision-making authority to terminate apps as discussed in (iii) below.

ii.
We logged into the emulator using adb shell and searched for the zygote binary using a variety of mechanisms, and we were unable to find it.  At first this seems non-intuitive: since a process is a program in execution, one would think that the program binary must exist somewhere in the filesystem to have been loaded into memory to actually execute it.  However, we know that this is not always the case.  For example, during bootup, the kernel creates the init process essentially "from scratch".  The code for the init process are probably embedded within the kernel image and are not a separate binary.  We expect the same may be true of zygote.
  
iii.
Our hypothesis is that zygote is responsible for managing the resources of all "apps", which are the processes running programs that the user can actually see and care about.  As the user opens more and more apps, the device cannot continue running all of them in the background because it does not have sufficient resources (particularly memory).  Therefore, we think it is zygote's responsibility to keep track of which apps were most recently used and which least recently used and, when resources are low, to kill processes for the apps least recently used.

A process like zygote must be specific to the embedded system, because the kernel itself is generic and cannot be expected to know which processes are most important to the user and which can be killed.  From the kernel's perspective, there is no different between a process running in the foreground (visible on the UI) and a process running in the background (not visible on the UI).  These details are specific to the system, so zygote rather than the kernel manages them.


Citations:
None
